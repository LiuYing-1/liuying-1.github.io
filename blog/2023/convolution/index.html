<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="googlece17f0a456a89a36.html"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Convolution | Y. Liu </title> <meta name="author" content="Y. Liu"> <meta name="description" content="Pixel-wise Operations, Intensity, Transformations, Image Formation, and the Convolution Integral."> <meta name="keywords" content="ku, ucph, copenhagen, diku, portfolio-website, liuying, dk, yingliu, ying liu, liu ying"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/favicon.png?157bbd74cef60250fd5a67a2e078966e"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://liuying-1.github.io/blog/2023/convolution/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Convolution",
            "description": "Pixel-wise Operations, Intensity, Transformations, Image Formation, and the Convolution Integral.",
            "published": "February 12, 2023",
            "authors": [
              
              {
                "author": "Ying Liu",
                "authorURL": "https://di.ku.dk/Ansatte/forskere/?pure=da/persons/762476",
                "affiliations": [
                  {
                    "name": "DIKU, UCPH",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Y.</span> Liu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">Ctrl K <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Convolution</h1> <p>Pixel-wise Operations, Intensity, Transformations, Image Formation, and the Convolution Integral.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#"></a> </div> </nav> </d-contents> <div align="center"><img src="https://i.imgur.com/k1XNh2S.jpg" style="zoom: 80%"></div> <div class="reference" style="color: #999; font-size: 0.8em; margin-top: 1em; margin-bottom: 1em;">Reference: Lecture from <a href="https://di.ku.dk/english/staff/vip/researchers_image/?pure=en/persons/83684" _target="blank" rel="external nofollow noopener" target="_blank">Kim Steenstrup Pedersen</a> </div> <h2 id="pixel-wise-operations">Pixel-wise Operations</h2> <h3 id="image-file-formats-and-compression">Image file formats and compression</h3> <p>Here is just an overview of various file formats to give you an idea of how we can store and read the images. There are many different file formats that have made both storing on disk and transferring images on the web.</p> <p>It depends on the application area and which format you use. In this course, we are going to use the following sets of formats.</p> <p><strong>JPEG</strong></p> <ul> <li>Provides <strong><u>lossy compression</u></strong> and can store pixel data in the <strong><u>quantization of 8 bit unsigned integer per color channel (RGB)</u></strong>. Compression level <strong><u>is controlled by a quality parameter</u></strong>.</li> </ul> <p><strong>PNG</strong></p> <ul> <li> <p>Provides <strong><u>lossless compression</u></strong>. Can store pixel data in the quantization of 1, 2, 4, 8, or 16 bit unsigned integer per channel and supports pixel formats grayscale, RGB, indexed, grayscale and alpha, and RGBA (A=alpha channel). <strong><em>Alpha channel</em></strong> is the channel for transparency.</p> </li> <li> <div style="font-family: 'Noto Serif SC'">阿尔法通道（α Channel或Alpha Channel）是指一张图片的透明和半透明度。例如：一个使用每个像素 16 比特存储的位图，对于图形中的每一个像素而言，可能以 5 个比特表示红色，5 个比特表示绿色，5 个比特表示蓝色，最后一个比特是阿尔法。在这种情况下，它要么表示透明要么不是，因为阿尔法比特只有0或1两种不同表示的可能性。</div> </li> </ul> <p><strong>TIFF</strong></p> <ul> <li>Provides <strong><u>lossless compression</u></strong> and allows for <strong><u>no compression</u></strong> as well. Can <strong><u>store pixel data in quantization of 1 to 32 bit unsigned integer per channel</u></strong> and supports pixel formats bilevel, grayscale, indexed, RGB and others. Allows to <strong><u>store multiple images</u></strong> in one file. Share raw data between cameras.</li> </ul> <h3 id="lossless-versus-lossy-compression">Lossless versus lossy compression</h3> <div align="center"><img src="https://i.imgur.com/hJssMnS.png" style="zoom:67%;"></div> <p>Lossless compression preserves all information and the process is invertable. That means, we can decompress and get exactly the same as input to the compression algorithm. Lossy compression is done by approximating the image (throwing away information). That means you cannot invert the process and get the same image back as you put into the compression algorithm. But lossy compression usually leads to much more higher compression factor so more compact representations than lossless compression does.</p> <div style="font-family: 'Noto Serif SC'">表示更紧凑</div> <p>Compression is a huge topic but out of scope for this course.</p> <h3 id="lossy-image-compression-creates-artifacts">Lossy image compression creates artifacts</h3> <p><strong>Can be devastating to image processing and analysis.</strong></p> <p>What is the consequence with the JPEG compression, especially when we have very low quality representation (a low quality parameter), the point is that it has a potentially devastating effect. Below is an example.</p> <div align="center"><img src="https://i.imgur.com/cYEAicX.png" style="zoom: 33%;"></div> <p>This image is stored in JPEG, and the quality parameter was chosen very low. So the file size is low, but the quality of the image is pretty bad. If we look carefully, we might see more blocking effects up in the sky, like patches of sky where it seems that you have a constant color, and you can see sharp edges between them.</p> <p>If we start to do some manipulation, I’m just taking the RGB image converting it to the Hue representation color space. And then, I just show the Hue channel. Remember the Hue channel is just one value per pixel thing. I here used matplotlib <em>HUE</em>.</p> <p>It is clear that there’s something come completely wrong with this image. We see fake structures these checkerboards so we can get misleading results. So in general, <u>we should be careful using lossy compression when we want to do image processing and analysis, because you have this effect that you are throwing away information. Especially if you use a low quality parameter when you do this JPEG compression.</u></p> <h2 id="basic-pixel-wise-operations">Basic pixel-wise operations</h2> <h3 id="image-blending---simulate-motion-blur">Image blending - simulate motion blur</h3> <div align="center"><img src="https://i.imgur.com/BztlJ2b.png" style="zoom:25%;"></div> <p>Simple mathematcial operations that we want to do on images.</p> <p>Pixel-wise operations, this means, it’s a mathematical operation that I apply to every single pixel in an image.</p> <p>An example of what we might want to do are</p> <ul> <li> <p>Adding or subtracting a constant</p> \[J(r, c) = I_A(r, c) + C\] <p>I take some input image $I_A$, and add pixel given at row $r$, and column $c$ and add some constant $C$. At any other pixel, I do the same thing, adding a constant, then, I get a result image where it’s the original image where every pixel has been shifted by this constant here. You should figure it as we don’t really change the spatial structure or the pixels. We only change wahtever values you have inside the stored in it.</p> </li> <li> <p>Multiplication or division by a constant</p> \[J(r, c) = C\cdot I_A(r, c)\] <p>It’s pixel-wise. We multiply by this constant $C$ at every pixel $(r, c)$. That returns a new image $J$.</p> </li> <li> <p>Adding or subtracting images (pixel-wise)</p> \[J(r, c) = I_A(r, c)+I_B(r, c)\] <p>We can incolve several images. For instance, we can take two images, $I_A$ and $I_B$ and add them together. Pixel-wise add or subtract if you want, that means, for a specific pixel at row $r$ and column $c$, we take whatever value we have stored in the image $A$ and add it to whatever value we have stored in the image $B$ and that gives you a new resulting pixel value that we store in this image $J$ at the pixel $(r, c)$.</p> </li> <li> <p>Multiplication or division of images (pixel-wise)</p> \[J(r, c) = I_A(r, c)\cdot I_B(r, c)\] </li> </ul> <p>All operations here are done per pixel.</p> <p>! <strong><em>Notice</em></strong>: When we do this, we need to be careful and think about the quantization levels that we have chosen for our image representation. We can easily get either over- or underflow as we do see these operations. So, normally, we need to combine such operations (pixel-wise) with some clippling of the range of output.</p> <p>For example, you choose an 8-bit representation for every pixel. And it’s an 8-bit unsigned pixel. If I do the first adding operation, add a constant that make a new resulting pixel value in $J$ larger than what we can represent in 8-bit unsigned integer so that is larger than 255. It would have overflow.</p> <h3 id="reminder---quantization-of-samplespixelsvoxels">Reminder - Quantization of samples/pixels/voxels</h3> <p>We have the quantization levels depending on what type of images we store. You might have this problem with under and overflow quicker than in other forms. If you think in terms of 8-bit unsigned integer, then you would very fastly run into this problem. Binary is even worse.</p> <h3 id="images-in-python-and-scikit-image">Images in Python and Scikit-Image</h3> <p><strong><em>How do we do this manipulations in Python and using this Scikit-Image pack?</em></strong></p> <p>The first thing to notice is that Scikit-Image uses the numpy arrays as the representation of the image. So once you’ve loaded an image in by Scikit-Image, what you get returned is a numpy array. <code class="language-plaintext highlighter-rouge">numpy.ndarrays</code></p> <p>That means you can all the operations that you can normally do on numpy arrays, you can also do that on this kind of image arrays. They are the same data structure.</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">numpy.ndarrays</code></p> </li> <li> <p>For-loops are slow in Python, so a more efficient way of applying pixel-wise operations is to <strong><u>use numpy's functionality of broadcasting</u></strong>.</p> <ul> <li> <p>Here is an example of adding a constant to all pixels</p> <div class="language-py highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">skimage.io</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="n">I</span> <span class="o">=</span> <span class="nf">imread</span><span class="p">(</span><span class="sh">'</span><span class="s">myimage.jpg</span><span class="sh">'</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">50</span> <span class="c1"># Adds 50 to all pixels in I
</span></code></pre></div> </div> </li> <li> <p><strong>Both <code class="language-plaintext highlighter-rouge">I</code> and <code class="language-plaintext highlighter-rouge">J</code> are <code class="language-plaintext highlighter-rouge">numpy.ndarrays</code> of the same dtype and shape.</strong></p> </li> <li> <p>The data type of every pixel is stored in the attribute called dtype.</p> </li> </ul> </li> <li> <p>Be careful what dtype your image has - when manipulating pixel values overflow and underflow may occur.</p> </li> <li> <p>Handle this by clipping and type casting: =&gt; Method 1</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">skimage.io</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="n">I</span> <span class="o">=</span> <span class="nf">imread</span><span class="p">(</span><span class="sh">'</span><span class="s">myimage.jpg</span><span class="sh">'</span><span class="p">)</span> <span class="c1">#dtype = unit8
</span><span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="sh">'</span><span class="s">int16</span><span class="sh">'</span><span class="p">)</span> <span class="o">+</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="sh">'</span><span class="s">uint8</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div> </div> <p>I changed the dtype of it and you can do this with <code class="language-plaintext highlighter-rouge">astype</code> method. I change it to signed 16 bit integer, and now I add 50. And the result of this is an numpy array that has the same shape as <code class="language-plaintext highlighter-rouge">I</code>. But now has the dtype in 16 bit. The idea is that make sure that I pick a data side that can actually represent the result of this edition.</p> <p>But what I want is actually not something that represented in 16 bits. I want to make sure that the resulting image $J$ is get converted back to unsigned integer 8 bit integer something that I might be able to write down to a new JPEG file. The way to do that is to use the built-in function in numpy function which is called <code class="language-plaintext highlighter-rouge">clip</code>.</p> <p>It takes some array that’s given by the result of this evaluating this expression. And it also takes a range of values that I want to ensure that all elements of this result that they are clipped or put into this range. So here I say that whatever the values are here, they should fit in the range $0\to 255$. So, if I have a value that’s bigger than 255, this value gets changed into 255. If I have a value that’s less than 0. So it’s a negative number, then it gets changed into 0. It doesn’t do any clever scaling or anything it just cuts off values that are outside this range them into the limits of this range. Once I have done that, it’s safe to convert this resulting array back ot 8 bit unsigned integer because we know that it can be stored in an unsigned 8 bit integer. So I use again this function to convert it back. So the result is that $J$ has the same shape as $I$, and has the same dtype.</p> </li> <li> <p>Or switch dtype, to floating point representation:</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">skimage.io</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">from</span> <span class="n">skimage</span> <span class="kn">import</span> <span class="n">img_as_float</span>
<span class="n">I</span> <span class="o">=</span> <span class="nf">img_as_float</span><span class="p">(</span><span class="nf">imread</span><span class="p">(</span><span class="sh">'</span><span class="s">myimage.jpg</span><span class="sh">'</span><span class="p">))</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">50</span> <span class="c1"># Now both I and J has dtype = float
</span></code></pre></div> </div> <p>Start by switching my dtype to <strong><u>floating points representation</u></strong>. After the operation, convert it back by using clipping trick back and convert to 8 bit before I can save it into something like JPEG image.</p> </li> </ul> <h3 id="file-formats-for-float-images">File formats for float images</h3> <p>If I want to save the resulting image as a floating point image, I cannot use the standard image formats like PNG, JPEG and TIFF, and so on. I need to use some other format. Here aer some suggestions of the numpy as your way to save the floating point images.</p> <p>Now there are two types of files. You can save with the .npy (one array) and .npz (several arrays). =&gt; .npz is the file format that you can save multiple images in one file.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">numpy.save</code> saves a numpy array to disk in a file (.npy).</li> <li> <code class="language-plaintext highlighter-rouge">numpy.savez</code> saves several numpy arrays to disk in a file. (.npz)</li> <li> <code class="language-plaintext highlighter-rouge">nump.load</code> loads the content of <code class="language-plaintext highlighter-rouge">.npy</code> and <code class="language-plaintext highlighter-rouge">.npz</code> files.</li> </ul> <h3 id="change-the-contrast-to-improve-visibility">Change the contrast to improve visibility</h3> <div align="center"><img src="https://i.imgur.com/W7lFGHg.png" style="zoom: 25%;"></div> <p>Some effects of performing some of these basic operations to all pixels that we have discussed.</p> <p>So the basic operations like this could think of that as a very simple way of doing contrast change. We’re going to talk its essence use basic operations on each pixel.</p> <p>So we build up more complicated algorithms for instance, for enhancement based on operations like these.</p> <h3 id="pixel-wise-intensity-transformations">Pixel-wise intensity transformations</h3> <h4 id="image-negative">Image negative</h4> <p>I took the a grayscale image and I want to produce the image in the right part.</p> <div align="center"><img src="https://i.imgur.com/7UXn3Z4.png" alt="image-20230212205444105" style="zoom: 25%"></div> <p>This is by a function $g$ that I want to apply to every pixel. I want to use pixel-wise.</p> <p>If we have an image like this, it’s an 8 bit unsigned integer representation. But that’s no guarantee that the range of these pixel values are between $0$ and $255$. So if I take into account what the actual effective range of pixel values are, I get a nice looking result image.</p> <p>So if I look through all of the pixels and record just the smallest intensive value. In this case is 25, and the maximum intensive value is 245. Then I can construct the nice looking image here by choosing the function $s = g(r)=I_{max} + I_{min} - r$ where I compensate for this range by <strong><u>adding maximum and minimum and then subtracting whatever pixel value I have in the input image</u></strong>.</p> <p>The important part is that this shows you that I can make a function that I can apply to every single pixel, so it’s applied pixel-wise.</p> <p>The result images that for every pixel $(x, y)$, I apply the $g$ function and then, I get a new pixel value that I store in my new image $J$ at the corresponding pixel location. I do that for all pixels.</p> <p>In Python and using numpy, you can do this. You just have to define a function that represents $g$ and then takes one variable as its input $r$ and then this can be applied to all pixels by numpy broadcasting.</p> <p><strong>Subsummary in this part</strong></p> <p>The <strong>Dynamic range</strong> is the actual range of intensity values $[I_{min}, I_{max}]$ present in the image. This does not have to be identical to the quantization limits.</p> <p>We can change the <strong>dynamic range</strong> of an image by applying <strong>function</strong> $g$ on intensity values.</p> <p>In general, we can apply some function $g$ to the intensities pixel-wise</p> \[J(x, y) = g(I(x, y))\] <h4 id="logarithmic-transform-of-intensities">Logarithmic transform of intensities</h4> <p>Compress the dynamic range</p> \[J (x, y) = c \ln [1 + (e^\alpha - 1)I(x, y)], \alpha &gt; 0.\] <p>Scale to output intensity range, e.g.,</p> \[c = \frac{255}{\ln [1 + \max (I(x, y))]}\] <p>Stretch the lower intensities (dark) and compress the higher intensities (bright).</p> <div align="center"> <img src="https://i.imgur.com/EEN9TPA.png" alt="image-20230212211826450" style="zoom: 20%;"><img src="/Users/liuying/Library/Application%20Support/typora-user-images/image-20230212211955176.png" alt="image-20230212211955176" style="zoom: 20%;"> </div> <p>Use if you have an image with bright and dark regions and you are interested in the details in the dark regions.</p> <h4 id="exponential-transform-of-intensities">Exponential transform of intensities</h4> <p>Stretch the dynamic range</p> \[J (x, y) = c[(1+\alpha)^{I(x, y)} - 1], \alpha &gt; 0.\] <p>The opposite of lograithmic transform: Compress the dark pixels and stretch the bright pixels.</p> <div align="center"> <img src="https://i.imgur.com/1AKzXDG.png" alt="image-20230212212240921" style="zoom:25%;"><img src="https://i.imgur.com/IBvY89f.png" alt="image-20230212212419752" style="zoom:25%;"> </div> <h4 id="power-law-gamma-transform">Power-law (Gamma) transform</h4> <p>Compression and stretching of dynamic range</p> \[J(x, y) = c[I(x, y)]^\gamma, \gamma &gt; 0\] <p>and $c$ chosen to map input dynamic range full output range.</p> <div align="center"> <img src="https://i.imgur.com/vzcgtVe.png" alt="image-20230212212637530" style="zoom:25%;"><img src="https://i.imgur.com/vYQSRhz.png" alt="image-20230212212705093" style="zoom:25%;"> </div> <p>Some other applications of gamma-correction:</p> <ul> <li> <p>Improve the raw signal from the CCD chip</p> </li> <li> <p>Enhance intensities to fit display hardware</p> </li> </ul> \[J(x, y) = h(g(I(x, y)))\] <h4 id="gamma-correction-on-a-color-image">Gamma correction on a color image</h4> <div align="center"><img src="https://i.imgur.com/jUHRhVM.png" alt="image-20230212213001714" style="zoom:25%;"></div> <h4 id="effect-of-degrading-the-intensity-quantization">Effect of degrading the intensity quantization</h4> <div align="center"><img src="https://i.imgur.com/D6iH1HB.png" alt="image-20230212213051704" style="zoom:25%;"></div> <p>Let’s go back to quantization level because that’s also a little bit of extra information that we can get from the resolution that we have in quantization. How many quantization do we have?</p> <p>In the previous example, we see that lowering the quatization, we will see the effect of that we lost details in the resolution. But we can also study the effect of each of the bits that we use to represent the intensity values.</p> <h4 id="bit-plane-slicing">Bit-plane slicing</h4> <p>If we consider the concept of a bit-plane.</p> <p>If we think of an image as at every pixel we have 8 bits to store the value. Then we can consider the least signifincant bit first. Let’s slice off all the remaining bits and only consider the least significant bit. If we do that for all pixels, then you could think of this as a binary image. =&gt; Bit-plane.</p> <p>I can do this for any of the bits in our representation all the way up to the most significant bit.</p> <div align="center"><img src="https://i.imgur.com/GeDfW5H.png" alt="image-20230212213829828" style="zoom:25%;"></div> <p>So slicing off the least significant bit means that I take only the first bits for each pixel.</p> <p>An image represented with a byte in each pixel (e.g., grayscale images) maybe decomposed into the individual bit-planes =&gt; This is called bit-plane slicing.</p> <p>Bit-planes can be extracted using the bitwise <code class="language-plaintext highlighter-rouge">AND</code> operator on the pixel and a bit mask for the bit-plane. E.g., use <code class="language-plaintext highlighter-rouge">numpy.bitwise_and()</code>.</p> <p>Useful in image coding and compression. =&gt; Applications Example below.</p> <div align="center"><img src="https://i.imgur.com/5Etnbpq.png" alt="image-20230212214309049" style="zoom:25%;"></div> <p>We apply a bit mask that selects each of the bits so this is a binary image and it shows what is stored in the least significant bit (first). All the way up to the most significant bit.</p> <p><strong><u>It's fairly difficult to see any structure in the least significant bit, and the second and the third. So that means the number changes in the actual numbers that are stored in the pixels. That this doesn't carry much information about what is actually in the image.</u></strong></p> <p>So if you consider the most significant bit, it looks like the most significant bit can see sort of the large scale structures of the image. We can actually see the face but we don’t have like minor details like in the texture and the hiar and so on. But we have an idea of what this is stored.</p> <p><strong><u>Now this gives you an idea of how you can actually do compression because what we might want to store is not the least significant bits. So in this case, we would actually throw away the first second and third bit and only save the last five bits.</u></strong> And this would be a lossy compression algorithm.</p> <h4 id="application">Application</h4> <div align="center"><img src="https://i.imgur.com/6vtP1BL.png" alt="image-20230212215540544" style="zoom:20%;"></div> <p><strong>Keeping only the 5 most significant bits. Bits 1~3 is set to zero in the reconstruction.</strong></p> <p>It’s difficult to see the changes and we can actually illustrate what the differences between the original and this compressed image by subtracting this image and htis image from each other in a pixel wise manner. So that means I take image one subtract image 2. And then, I can see the difference image. It’s not a binary image, but an image where I have values that are stored in the least significant bit from 1 to 3 bit. It’s actually a grayscale image.</p> <p>It is the fact that we can see some details in the difference image, but mostly are some rubbish that we can throw that away.</p> <p>And here we get the lossy compression algorithm that thrown away the least information.</p> <h2 id="image-formation">Image formation</h2> <h3 id="a-mathematical-model-of-image-formation">A Mathematical Model of Image Formation</h3> <p>Now, we are going to develop a mathematical model for a image formation.</p> <p>Here means <strong><u>the process of taking a picture with our camera</u></strong>.</p> <p>So that model will be developed using an optical imaging system as the model as driving the example. But the model can be used for any imaging device whether this is a telescope or normal camera with microscope, CT scanner or a mask scanner or whatelse we could come up with.</p> <p>So let’s start out with defining what is the optical imaging system.</p> <p>We already talked about obscure / pinhole camera.</p> <p>I showed you this illustration before you have light out in the real world that goes into the camera by a pinhole. We will refer to this as the <strong><u>aperture</u></strong> of our imaging device. In the optical case, we have all light travels through straight line goes through the pinhole and it goes into the camera and hits the back side of the camera. This back side will call the <strong><u>image plane</u></strong>. We have information out in 3D that gets predicted into this image plane. This is known as a <strong><u>perspective projection</u></strong>.</p> <p>You can have all the types of cameras where you don’t have this perspective projection. =&gt; <strong><em>Orthogonal Projection</em></strong></p> <p>But in this course, we only talk about perspective projection and this is an idealized view of what is going on when we take pictures with a camera.</p> <p>In the real camera, the pinhole is of some finite size and it’s not just a point. And infront of it, we would usually have some lens that collect the light and focuses on the pinhole.</p> <div align="center"><img src="https://i.imgur.com/PqoHcld.png" alt="image-20230213000948251" style="zoom:25%;"></div> <h4 id="perspective-projection">Perspective projection</h4> <p>Perspective projection causes:</p> <ul> <li>Foreshortening - the apparent size of objects depends on distance to viewer.</li> <li>Convergence - Parallel lines meet in vanishing points.</li> </ul> <p>There are a lot of extra things to go with perspective projection. =&gt; Advanced courses for reconstructing 3D points what we see via camera.</p> <h4 id="a-snippet-of-computer-vision">A snippet of computer vision</h4> <p>There is a mathematical model that describes what the pinhole camera does this idealized camera.</p> <p>The pinhole camera performs a perspective projection onto the image plane.</p> <div align="center"><img src="https://i.imgur.com/JlL3XRy.png" alt="image-20230213002803981" style="zoom:25%;"></div> <p>We have a point out here in the real world which could be described by a 3D coordinate. Let’s call it $P$ and the coordinates are given by this triplet. It sends out some light and we see it in the camera by the light that travels in the straight line through the pinhole and continuously unit it hits the image plane.</p> <p>So in reality, you could think of it to find the point in the image plane and you need to form this line here that goes from this 3D point where the pinhole is in 3D and then trace the line unit it hits the image plane.</p> <p>The 2D coordinates in the image plane is $p$. The $Z$ parameter in original 3D is replaced by the parameter $\frac{f}{Z}$ which is transformed into 2D projection.</p> <p>Generally, the pinhole is called the optical center, and the distance between the image plane and the optical center is called the focal length $f$ and this is the property of the camera which is fixed.</p> <p>So this just tells us about how we can map a 3D point onto the image plane so onto a pixel coordinate in the image. =&gt; Ordinary camera</p> <h4 id="some-observations">Some observations</h4> <p>What we need right now is a model of what happens light travels from out in the real world through potentially some <strong>optics</strong> through the <strong>aperture pinhole</strong> and onto the <strong>image plane</strong>.</p> <p><u>First of all, any optical system (camera with an optical lens) that you might put in front of the camera will distort and smear / blur the resulting image (with varying degree depending on the quality of the opticals).</u></p> <p>The <u>size of the pinhole / aperture</u> has a smearing / blurring effect. So the larger the hole is, the light goes through the more smeared out the image might actually appear.</p> <p>A digital sensor (e.g., CCD chip) will smear / blur the image a bit due to the fact that <u>sensor cells are not infinitesimally small</u>.</p> <p><strong><em>If we want to form a mathematical model of an imaging system, we need to consider the effect of three factors above.</em></strong> And this will end up with a very central concept in signal processing called <strong><u>convolution</u></strong>.</p> <p>Convolution is a processing tool that performs changes to an image and generates new image. We can also use it as the machinery in image analysis.</p> <h3 id="a-mathematical-model">A mathematical model</h3> <p>We want to model the process of forming an image with our imaging system. =&gt; A camera</p> <p>Consider an imaging device as a system that maps input <strong>distributions of light</strong> (in general electromagnetic radiation) to output <strong>light distributions</strong> on the image plane. =&gt; How much light do we have in different areas in front of the camera and how does that gets mapped onto the image plane.</p> <p>We will represent the imaging system with an operator $S$ acting on the input distribution $I$, $O=S{I}$.</p> <div align="center"><img src="https://i.imgur.com/xzpoMVR.png" alt="image-20230213010543381" style="zoom: 25%"></div> <p>We have some input light distribution $I$ which in reality is some distribution in 3D world in front of us, then, the camera applies some operator $S$ on the input distribution and generates as output at distribution on the image plane.</p> <h4 id="imaging-systems-as-a-linear-system">Imaging systems as a linear system</h4> <h5 id="first-assumption">First assumption</h5> <p>We will for simplicity use a linear system as model. We think of it as a function that maps the distribution to another distribution.</p> <p><u>An operator $S$ is linear, if $S\{aX+bY\}=aS\{X\} + bS\{Y\}$.</u></p> <p>This means, if I have two different light distributions $X$ and $Y$, two constants $a$ and $b$. Then, applying the imaging system by the operator $S$ to distribution $x$ and the distribution $Y$ Separately. Multiplying them by some constants $a$ and $b$ and adding together. This should give the same result as if I took the $x, y$ distributions multiplied by some constant $a$ and $b$ and added them together. Finally, applied my camera $S$ operator.</p> <p>So, this equality must hold for is to be linear. Illustrative example is below.</p> <div align="center"><img src="https://i.imgur.com/DdCwpvG.png" alt="image-20230213011957243" style="zoom:25%;"></div> <h5 id="second-assumption">Second assumption</h5> <p>Open up the black box of $S$ and try to be a bit more precise.</p> <div align="center"><img src="https://i.imgur.com/JOea4fD.png" alt="image-20230213012518127" style="zoom:25%;"></div> <p>Let’s try to model the camera in this way.</p> <p>We’re goingto assume that the camera contains two components, PSF and some noise. =&gt; $S{I}=PSF{I} + noise$.</p> <p>$PSF$ is the Point Spread Function and it must be a linear operator, otherwise, our $S$ will not be linear.</p> <p>Noise - will model the non-deterministic part of the imaging system.</p> <p>The process is that camera took the light source as an input, and then apply $S$ so that our resulting image is the output which has been smeared out.</p> <h5 id="sources-of-noise-in-image-formation-systems">Sources of noise in image formation systems</h5> <p><strong>Common sources of noise.</strong></p> <p>As we take pictures, there are vaiours sources of noise and all depends on the type of camear or imaging system that you have.</p> <p><strong>Capture</strong></p> <ul> <li> <p>It could be for instance, if you take an ordinary optical camera and take pictures, then there might be some fluctuations in the actual amount of light that you see out in the scene and that hits the optical system of the camera. In the end gives some variation. If you kept on taking pictures off the same scene with the camera, you will have small variations due to changes in the light. =&gt; <strong>Variations in lighting</strong></p> </li> <li> <p>If you take pictures out with a telescope up into space, the atmosphere also causes some noise. Cloud that on the way could be the noise. =&gt; <strong>Atmospheric effects</strong> so that can change the amount of light that hits camera.</p> </li> <li> <p>Digital CCD chip is a piece of electronics and it’s sensitive to things like <strong>temperature</strong>, <strong>any electrical noise</strong> that might come from the power source. =&gt; Cause some random fluctuations of the amount of light that is measured by the sensor.</p> </li> <li> <p>Sensor non-uniformity, dust, vibrations, lens distortion, focus limitations, sensor saturation (too much light), underexposure (too little light).</p> </li> </ul> <p><strong>Sampling</strong></p> <p>Sampling resolution and quantization leads to aliasing effects.</p> <p><strong>Processing</strong></p> <p>When we do some processing in the camera collecting the light, some post processing after the sensor that can cause some numerical problems with precision. Overflow and approximation.</p> <p>The camera automatically performs JPEG compression and in this way, we approximating the light and this is sort of a random fluctuation that changes the output light distribution that we are observed with our camera.</p> <p><strong>Image-encoding</strong>: Artifacts from lossy image compression.</p> <p>A reasonable model is to assume that imaging noise is independent of position and identically distributed (i.i.d).</p> <h5 id="salt-n-pepper-and-additive-gaussian-noise">Salt-n-pepper and additive Gaussian noise</h5> <p>This just shows you two examples of noise.</p> <p>The top one is called salt and pepper or impulse noise. =&gt; Model of a sensor element failure (off or oversaturated). CCD chip is either permanently broke or just temporarily broken.</p> <p>The <strong>Gaussian nose</strong> is the model of <strong>accumulated system noise</strong>. =&gt; We draw a random number from a Gaussian distribution that has zero mean and some variants and then we add that to the original value.</p> <div align="center"><img src="https://i.imgur.com/OseYqxc.png" alt="image-20230213020554474" style="zoom: 25%"></div> <p>Maybe we have a real camera and takes the original image. Besides the blurring effect of the camera, we also add some noise and map it to the imaging plane. These are just two examples of models of the type of noise that could occur in the process.</p> <h5 id="the-effect-of-our-model">The effect of our model</h5> <p>It takes a point light source and then, it smears it out so that it covers several pixels not just one pixel.</p> <p><strong>Simulation example</strong></p> <div align="center"><img src="https://i.imgur.com/ZWJn3bP.png" alt="image-20230213022318018" style="zoom:25%;"></div> <p>The smearing effect comes from the $PSF$, and the noise is using the i.i.d $Gaussian$ noise.</p> <h3 id="modeling-the-point-spread-function-psf">Modeling the Point Spread Function (PSF)</h3> <p>Now we need to develop a model for $PSF$ which is based on the assumption of a lienar operator.</p> <h4 id="linear-superposition-integral">Linear superposition integral</h4> <p>We are still aiming at modeling the imaging system.</p> <p>$PSF$ is that it should model the light gets smeared out. <u>A point light source that doesn't end up in a point in image plane but gets smeared out in the image plane.</u> That’s what we want the $PSF$ does.</p> <p>In the first step, we could assume that the $PSF$ operator is <u>linear superposition integral</u>. Lets model the $PSF$ operator as a position dependent weigthed average of the input - a superposition of the input.</p> <p>We assume that we have some input distribution, for simplicity, we draw it in 2D but all the other things are the same. Leads to the same result.</p> <p>If I consider a specific location in the imaging system, you could think of it as a specific pixel. How does that relate to light out in the real world out on his light distribution plane? What we assume is that there is some function $h$ that acts as a weighting function (something that has to do with $PSF$) that is multiplied together with the light distribution function $f$.</p> \[g(x, y) = \int\int f(x', y')h(x, y; x', y') dx'dy'\] <div align="center"><img src="https://i.imgur.com/dqvdcsD.png" alt="image-20230213025949187" style="zoom:25%;"></div> <p>The double integral equation here is saying that, to figure out what is the light distribution at $x, y$, we need to go via $h$ function, look at a specific location out on the input plane, and we need to consider all possible $(x’, y’)$ =&gt; all possible locations on the input plane. Let the contribution be weighted by $h$ function.</p> <div style="font-family: 'Noto Serif SC'">意思是对于输出层的某一个像素点，他有可能是输入层所有像素点均等权重相加的结果，也有可能是分配权重不均衡导致某几个权重大的点的影响因素较多的结果。</div> <p><strong><u>It's weird because it seems like we have an function that depnds on both the coordinate system out on the real world and the coordinate system on the image plane.</u></strong></p> <p>The way to think of this is that we allow $h$ to be different to change as we look at different places in the output. So you could maybe imagine a camera that doesn’t behave similarly for all the pixels in the image plane. =&gt; <strong>Position Dependent</strong></p> <p>But for ordinary cameras, this is not needed.</p> <h4 id="linear-shift-invariant-systems---the-convolution-integral">Linear shift-invariant systems - the convolution integral</h4> <p>Usually an imaging system has a $PSF$ which is <strong><u>independent of position</u></strong>, except telescope.</p> <p>But if we assume that the $PSF$ is position independent, then from the superposition integral (equation before), we can simplify the integral. That means we can change $h$.</p> <p>So what we will assume is that $h$ does not directly depend on $x$ and $y$. There exists some $h$ function of two variables what we need is that we shift this $h$ function around to simulate the model $PSF$.</p> \[h(x, y;x',y') = h(x-x', y-y')\] <p>This simplifies the superposition integral to</p> \[g(x, y) = \int^{\infin}_{-\infin}\int^{\infin}_{-\infin}f(x', y')h(x-x',y-y')dx'dy'\] <p>This is called the <strong><u>convolution integral</u></strong>.</p> <p>You will also see different notations for this because it’s pretty difficult annoying to keep having to write out double integrals.</p> <p>Instead of writing double integral, we use</p> <p><strong>2D</strong></p> \[g(x, y) = \{f*h\}(x,y)\] <p><strong>1D</strong></p> \[g(x) = \{ f*h \}(x)\] <hr> <p>$f*h \Leftrightarrow$ Apply convolution integral on the two function $f$ and $h$.</p> <hr> <div align="center"><img src="https://i.imgur.com/bq11zFg.png" alt="image-20230213034935897" style="zoom:25%;"></div> <h2 id="signal-processing-basics">Signal processing basics</h2> <h3 id="dirac-delta-impulse-functions">Dirac delta (impulse) functions</h3> <p>Haven’t been taught right now.</p> <h3 id="what-causes-the-psf">What causes the PSF?</h3> <p><strong>Finite apertures (pinhole) and sensors.</strong></p> <div align="center"><img src="https://i.imgur.com/r2FnSy9.png" alt="image-20230213040551883" style="zoom:25%;"></div> <p>Let’s consider a simplified imaging system where the camera is 1D or it’s a line scanner. The input signal $f(x’)$ is 1D.</p> <p>So $x’$ is the input space. We will consider the perfect camera case. This is the case where the aperture the pinhole is infinitely small. It’s through a point or sensor, the centering element in our chip, this is also infinitely small. In this case, we have this idealized setup because here the $PSF$ and $h$ function for the $PSF$ becomes a $\delta$ function. In this case, we get an exact copy of the input.</p> <div align="center"><img src="https://i.imgur.com/14i1N66.png" alt="image-20230213121226260" style="zoom:25%;"></div> <p>We model the effect of the apeture with $h(x)$. And this function is part of the $PSF$ of the camera. So we only need to worry about the aperture and this is the cause of the $PSF$.</p> <div align="center"><img src="https://i.imgur.com/hKUk0Pp.png" alt="image-20230213121533071" style="zoom: 25%"></div> <p>$h_d(x)$ and $h(x’)$ together form the final output image and they form the system $PSF$. So, how does this work?</p> <p>You can think of it as what is the amount of light that goes throuh the finite aperture? We know that’s given by convolving with the corresponding $h$ function and the input signal $f$. And this gives you some intermediate result just after the finite aperture. =&gt; $g(x)$.</p> <p>Now we have this finite sensor as well and that we take whatever comes out of the aperture, and we convolve that by $h_d$. And that is the resulting image given by our camera.</p> <p>We can definitely write our resulting image as below.</p> \[I(x) = f(x')*h(x)*h_d(x)\] <p>But we can combine these together and find a combined $h$ function that both models the finite aperture and the finite sensor size. We cam do this simply by convolving the two $h$ together prior to convolving wiht the input signal and in practice, it’s pretty difficult to separate the different effects from each other.</p> <p>On top of this, we might also see blurring effects from other parts of the imaging system, e.g., from optical lenses, which will add yet another term to the $PSF$.</p> <h3 id="example-of-simulating-low-photon-count">Example of simulating low photon count</h3> <div align="center"><img src="https://i.imgur.com/IhDiZPq.png" alt="image-20230213122628472" style="zoom: 25%"></div> <p>Some times, we can get a more visible version compared to the original picture.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"LiuYing-1/liuying-1.github.io","data-repo-id":"R_kgDOJQ12MQ","data-category":"Announcements","data-category-id":"DIC_kwDOJQ12Mc4CVcDU","data-mapping":"pathname","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Y. Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-JC70RZ57BT"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JC70RZ57BT");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>