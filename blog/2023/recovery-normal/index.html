<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="googlece17f0a456a89a36.html"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Recovery &gt; Normal | Y. Liu </title> <meta name="author" content="Y. Liu"> <meta name="description" content="This is the special part for recovery and normal."> <meta name="keywords" content="ku, ucph, copenhagen, diku, portfolio-website, liuying, dk, yingliu, ying liu, liu ying"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png?157bbd74cef60250fd5a67a2e078966e"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://liuying-1.github.io/blog/2023/recovery-normal/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Recovery > Normal",
            "description": "This is the special part for recovery and normal.",
            "published": "January 07, 2023",
            "authors": [
              
              {
                "author": "Ying Liu",
                "authorURL": "https://di.ku.dk/Ansatte/forskere/?pure=da/persons/762476",
                "affiliations": [
                  {
                    "name": "DIKU, UCPH",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Y.</span> Liu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">Ctrl K <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Recovery &gt; Normal</h1> <p>This is the special part for recovery and normal.</p> </d-title> <d-byline></d-byline> <d-article> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/NMeVaGS.png" alt="image-20230104213954735" style="zoom:80%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <h2 id="recovery">Recovery</h2> <h3 id="do-it-yourself-recap-the-many-faces-of-atomicity">Do-it-yourself-recap: The many faces of atomicity</h3> <ul> <li> <strong>Atomicity</strong> is strong modularity mechanism! <ul> <li>Hides that one high-level action is actually made of many sub-actions</li> </ul> </li> <li> <strong>Before-or-after</strong> atomicity <ul> <li>== Isolation (AC<b>I</b>D)</li> <li>Cannot have effects that would only arise by interleaving of parts of transactions</li> </ul> </li> <li>What was the meaning of <strong>all-or-nothing atomicity</strong>? <ul> <li>== Atomicity (<b>A</b>CID) =&gt; Cannot be partially executed</li> <li>== Duration (ACI<b>D</b>) =&gt; Once been committed, be visible forever durable.</li> </ul> </li> </ul> <h3 id="objectives-today">Objectives Today</h3> <ul> <li>Explain the concepts of <strong>volatile</strong>, <strong>nonvolatile</strong>, and <strong>stable storage</strong> as well as the <strong>main assumptions underlying database recovery</strong> </li> <li>Predict how <strong>force/no-force and steal/no-steal strategies</strong> for writes and buffer management influence the need for <strong>redo</strong> and <strong>undo</strong> </li> <li>Explain the <strong>notion of logging</strong> and the <strong>concept of write-ahead logging</strong> </li> <li>Predict <strong>what portions of the log and database are necessary for recovery</strong> based on the <strong>recovery equations</strong> </li> <li>Explain <strong>how write-ahead logging is achieved in the ARIES protocol</strong> </li> <li>Explain the <strong>functions of recovery metadata</strong> such as the transaction table and the dirty page table</li> <li>Interpret th<strong>e contents of the log resulting from ARIES</strong> normal operation</li> </ul> <h2 id="recovery-basic-concepts">Recovery: Basic Concepts</h2> <table> <tbody> <tr> <td>For this part, please review [Experi</td> <td>Recovery](https://liuying-1.github.io/advanced-computer-system/experi-recover/).</td> </tr> </tbody> </table> <h2 id="recovery-aries-normal-operation">Recovery: ARIES, normal operation</h2> <h3 id="recovery-equations">Recovery Equations</h3> <p><strong><em>Let’s talk about the algorithm, we need to support all REDO and UNDOs. What do we log and how do we log it?</em></strong></p> <h4 id="wal--the-log">WAL &amp; the Log</h4> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/9pIoUVM.png" alt="image-20230106162212065" style="zoom:50%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <p>What are the things that we need to store in the log to do our accounting, accounting is what happening in the system.</p> <p>First of all, we need IDs for the records that we store in the log and we will call <strong>log sequence number</strong> or just LSN. The log is a sequential thing, and LSNs always increasing. We will use this fact to compare to sequence numbers and to figure out what has happened before what.</p> <ul> <li>Each log record has a unique <strong>Log Sequence Number (LSN)</strong> <ul> <li>LSNs always increasing</li> </ul> </li> </ul> <p>Then, when we look at the <strong>data pages</strong> that are stored everywhere in the system both in memory and on disk, we will extend the data page beyond the actual data, also containing <strong>Log Sequence Number which is the most recent update to this page</strong>.</p> <ul> <li>Each <strong><u>data page</u></strong> contains a <strong>pageLSN</strong>. <ul> <li>The LSN of the <u>most recent log</u> record for an update to that page.</li> </ul> </li> </ul> <p>Moreover, the system will keep track of other special log sequence numbers. What does this special log sequence number (<strong>flushedLSN</strong>)? The log itself should live in stable storage, maybe the largest part of it. But still, when we extend it, we first need to go through RAM. The log itself will be split into a part that lives on the disk, and the part that lives on the RAM. And the <strong>flushedLSN</strong> is a kind of pointer to where the split happens between the two.</p> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/yFVU6XI.png" alt="image-20230106164519107" style="zoom: 33%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <ul> <li>System keeps track of <strong>flushedLSN</strong>. <ul> <li>The <strong>max</strong> LSN flushed so far.</li> </ul> </li> </ul> <p><strong><em>When a crash happens, we will lose the “Log tail” since it lives on the RAM.</em></strong> So this is not so perfect, this part will be lost and his will be our only information about actions that were happening in this period of time. =&gt; 1. We want to flush the log frequently. We want to make this time where entries log entries leave in the RAM as short as possible. 2. We are not aiming for perfection here, we will lose some information here. However, we don’t want to lose those entries.</p> <p>What does the <strong>write-ahead logging</strong> means? This means, whatever we write a page to the disk, we need to make sure that pageLSN which is the most recent record modifying the page is below what has been flushed. And what has been flushed means that the log record corresponding to this modification is already in the “blue” part.</p> <ul> <li>WAL: Before a page is written, <ul> <li>pageLSN &lt;= flushedLSN —-&gt; 否则，大于的部分无法恢复了</li> <li>https://zhuanlan.zhihu.com/p/482491814</li> </ul> </li> </ul> <h4 id="log-records">Log Records</h4> <p><strong>LogRecord fields</strong></p> <p>| prevLSN | XID | type | pageID | length | offset | old data | new data | | :—–: | :-: | :–: | :—-: | :—-: | :—-: | :——: | :——: |</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">prevLSN</code> is a pointer to the <strong>previous log entry by the same transaction</strong>. It’s kind of in addition to just having a sequential view on all the actions. We also <strong>storing this linked lists that correspond to the actions performed by a single transaction</strong>. So, when we maybe <strong>undoing</strong> things of a single transaction, we can focus more effectively on just this transaction don’t need to traverse the entire log. Just have easy access to the actions of a single transaction.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">type</code> -&gt; Possible log record types</p> <p>| Update | Commit | Abort | End | Compensation Log Records (CLRs) | | :—-: | :—-: | :—: | :-: | :—————————–: |</p> <p><code class="language-plaintext highlighter-rouge">Update</code> -&gt; <code class="language-plaintext highlighter-rouge">old data</code> &amp; <code class="language-plaintext highlighter-rouge">new data</code></p> <p><code class="language-plaintext highlighter-rouge">Commit</code> -&gt; signifies the start of <code class="language-plaintext highlighter-rouge">commit</code></p> <p><code class="language-plaintext highlighter-rouge">End</code> -&gt; As <code class="language-plaintext highlighter-rouge">commit</code> or <code class="language-plaintext highlighter-rouge">abort</code> also take some certain time, this signifies <strong>end</strong> of <code class="language-plaintext highlighter-rouge">commit</code> or <code class="language-plaintext highlighter-rouge">abort</code>.</p> <p><code class="language-plaintext highlighter-rouge">Compensation Log Records (CLRs)</code> -&gt; they will be recording the undo actions</p> </li> </ul> <h4 id="other-log-related-state">Other Log-Related State</h4> <p><strong>Transaction Table</strong> and <strong>Dirty Page Table</strong> are the <strong>data structures maintained in memory</strong>. This was kind of the local state of the algorithm that there’s responsible for recovery, but it will be <strong>completely lost on the crash</strong> and we will <strong>be using the log to reconstruct the state of these data structures</strong> at the moment of the crash.</p> <ul> <li> <p><strong>Transaction Table (XT)</strong></p> <ul> <li> <p>One entry per active transaction.</p> </li> <li> <p>Contains <strong>XID</strong>, <strong>status</strong> (running/commited/aborted), and <strong>lastLSN</strong>.</p> <p>| XID | Status | lastLSN | | :-: | :—-: | :—–: |</p> <p>So, what is the <code class="language-plaintext highlighter-rouge">lastLSN</code>? It is the last operation performed by a transaction. Kind of the entry point to the backwards pointing linked list associated with transaction. =&gt; <font color="red">Not fully understood</font></p> </li> </ul> </li> <li> <p><strong>Dirty Page Table (DPT)</strong></p> <ul> <li> <p>One entry per dirty page in buffer pool.</p> </li> <li> <p>Contains <code class="language-plaintext highlighter-rouge">recLSN</code> – the LSN of the log record which <u><b><i>first</i></b></u> caused the page to be dirty.</p> <p>| PID | recLSN | | :-: | :—-: |</p> </li> </ul> </li> </ul> <h3 id="normal-execution-of-a-transaction">Normal Execution of a Transaction</h3> <div align="center">It must be OK to crash <b>at any time -&gt; repeat history</b>!</div> <p><em>What do we do during normal execution of a transaction?</em></p> <p>Firstly, what is a transaction? A transaction is a series of <code class="language-plaintext highlighter-rouge">READ</code>s and <code class="language-plaintext highlighter-rouge">WRITE</code>s at least from our point of view followed by a <code class="language-plaintext highlighter-rouge">Commit</code> or <code class="language-plaintext highlighter-rouge">Abort</code> at the end. We have assumed that <em><u>writes to disk have no duration</u></em> as opposed to commits or aborts. But in practice, we need to handle the fact that writes also take time.</p> <ul> <li> <p>Series of <code class="language-plaintext highlighter-rouge">READ</code>s &amp; <code class="language-plaintext highlighter-rouge">WRITE</code>s, followed by <code class="language-plaintext highlighter-rouge">commit</code> or <code class="language-plaintext highlighter-rouge">abort</code>.</p> <ul> <li>We will assume that write is atomic on disk. <ul> <li>In practice, additional details to deal with non-atomic <code class="language-plaintext highlighter-rouge">WRITE</code>s.</li> </ul> </li> </ul> </li> <li>S2PL -&gt; concurrency is correctly handled =&gt; Isolated Correctly</li> <li> <code class="language-plaintext highlighter-rouge">STEAL</code>, <code class="language-plaintext highlighter-rouge">NO-FORCE</code> buffer management, with <code class="language-plaintext highlighter-rouge">Write-Ahead Logging</code>.</li> </ul> <h3 id="the-big-picture-whats-stored-where">The Big Picture: What’s Stored Where</h3> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/m77xouw.png" alt="image-20230106175408043" style="zoom:50%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <p>We have the log that somehow sits in the hypothetical stable storage. It contains all these things, but maybe not all entries, for example, the <code class="language-plaintext highlighter-rouge">pageID</code>, <code class="language-plaintext highlighter-rouge">length</code>, <code class="language-plaintext highlighter-rouge">offset</code>, <code class="language-plaintext highlighter-rouge">old data</code>, and <code class="language-plaintext highlighter-rouge">new data</code> are only for the <code class="language-plaintext highlighter-rouge">Update</code> entries. However, these things are always there.</p> <p>Then, we have the database, and the databases have been extended by the pointer of <code class="language-plaintext highlighter-rouge">pageLSN</code> =&gt; last modification to this page. We also have the master record.</p> <p><code class="language-plaintext highlighter-rouge">flushedLSN</code> indicates how the log is split between the parts that still in the RAM and the part that lives in the stable storage. Additionally, the log tail should also in the RAM. The two data structures, transaction table and dirty page table sit at memory.</p> <p><strong><em>Right now, we have to deal with the case where the RAM part is completely gone.</em></strong></p> <h3 id="checkpointing">Checkpointing</h3> <p>Before I tell you how we deal with the normal operation handle crashes. Here are the two extra log records. They can be seen as an optimization. <strong><em>What we want to avoid is that the recovery after crash takes a long time.</em></strong></p> <p>This happens <strong><em>when the transaction table and the dirty page table that we are losing</em></strong>. If you need to start from the beginning of time when reconstructing those, this will be a problematic. =&gt; So we want to <strong><em>make this point in time as late as possible from where we need to start working construction the transaction table and the dirty page table.</em></strong> And that’s we will take chekpoints of those and store them also in the log.</p> <p><em>We will initiate a checkpoint and it consists of the transaction table and the dirty page table. Initiating a checkpoint means starting writing these things to the log and once we are done, we create the end checkpoint record which contains the current state of the two tables (XT &amp; DPT).</em></p> <p><em>Then, when we recover, we can start from this state as opposed the empty table. So, this is called <code class="language-plaintext highlighter-rouge">fuzzy checkpoint</code> as it takes the time to write these tables. And the point is fuzziness.</em></p> <p><em>The other transcations continue to run. What is stored in the <code class="language-plaintext highlighter-rouge">end_checkpoint</code> record is the snapshot at the moment of the corresponding <code class="language-plaintext highlighter-rouge">begin_checkpoint</code> record.</em></p> <p><em>This is the reliable information. From that point (<code class="language-plaintext highlighter-rouge">begin_checkpoint</code>), we can rely on what is stored at this slightly later point in time and we will be recreating the state of our table starting from the earlier point.</em></p> <p>Since this is an optimization trying to bring the time as close to the present from which we need to start, it doesn’t actually matter that much that there is a certain operation that happened between the two.</p> <hr> <p><strong>Official Version</strong></p> <ul> <li> <p>Periodically, the DBMS creates a <u>checkpoint</u>, to minimize the time taken to recover in the event of a system crash. Write to log:</p> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">begin_checkpoint</code></strong> record: Indicates when checkpoint began.</p> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">end_checkpoint</code></strong> record: Contains current Xact table and dirty page table. This is a <strong><code class="language-plaintext highlighter-rouge">fuzzy checkpoint</code></strong>:</p> <ul> <li> <p>Other Xacts continue to run; so these tables accurate only as of time of the <strong><code class="language-plaintext highlighter-rouge">begin_checkpoint</code></strong> record.</p> </li> <li> <p><strong>No attempt to force dirty pages to disk</strong>; effectiveness of checkpoint limited by oldest unwritten change to a dirty page, <code class="language-plaintext highlighter-rouge">minDirtyPagesLSN</code>.</p> <p>We are not trting to force dirty pages to disk at any point. For the checkpoint, it is just about recording these tables, nothing about the actual data and the actual data is handled by the background process.</p> </li> <li> <p>Use <strong>background process</strong> to flush dirty pages to disk!</p> </li> </ul> </li> <li> <p>Store LSN of <code class="language-plaintext highlighter-rouge">begin_checkpoint</code> record in a safe place (<strong><em>master</em></strong> record). =&gt; This is the point from which we need to start our recovery.</p> </li> </ul> </li> </ul> <hr> <h3 id="transaction-commit">Transaction Commit</h3> <p><em>What should happen at when the transaction commits?</em></p> <ol> <li>We want to write <code class="language-plaintext highlighter-rouge">commit</code> record to the log and we want to write this as quickly as possible.</li> <li>Moreover, we want to flush all the records up to this <code class="language-plaintext highlighter-rouge">commit</code> record to the disk. And it guarantees us that <code class="language-plaintext highlighter-rouge">flushedLSN</code> will be greater than the <code class="language-plaintext highlighter-rouge">lastLSN</code> transaction that has committed. It will make sure that the user can rely on the information about the commit made it to the stable storage.</li> <li>These are sequentials and synchronous writes to disk. The log is sequential everywhere.</li> <li>We will try to have multiple of records per single log page. When we are writing a single log page, we are writing a lot of log reference.</li> </ol> <p>After we flush the log, then <code class="language-plaintext highlighter-rouge">Commit()</code> can return. Then the user gets the notification that “Your transaction has been committed”. You can rely that it’s durable.</p> <p><strong><em>Here I did not say anything about the actual data written to disk, this happens in background process.</em></strong></p> <p>Then, we need to update the local state (XT and DPT) of algorithm. After that, you will write the <code class="language-plaintext highlighter-rouge">end</code> record to the log.</p> <hr> <p><strong>Official Version</strong></p> <ul> <li>Write <code class="language-plaintext highlighter-rouge">commit</code> record to log.</li> <li>All log records up to Xact’s <code class="language-plaintext highlighter-rouge">lastLSN</code> are flushed. <ul> <li>Guarantees that <code class="language-plaintext highlighter-rouge">flushedLSN &gt;= lastLSN</code>.</li> <li>Note that log flushes are sequential, synchronous writes to disk.</li> <li>Many log records per log page.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">Commit()</code> returns.</li> <li>Update the local state.</li> <li>Write <code class="language-plaintext highlighter-rouge">end</code> record to log. =&gt; We don’t need to flush it immediately.</li> </ul> <p>The transaction is considered as committed as soon as the commit record makes it to the stable storage which is the last entry that’s flushed.</p> <hr> <h3 id="simple-transaction-abort">Simple Transaction Abort</h3> <ul> <li>For now, consider an explicit abort of a transaction. <ul> <li>No crash involved. =&gt; <strong>We did not lose our RAM yet.</strong> </li> </ul> </li> </ul> <p>What we want to do is UNDOing the effects of the transaction that happens so far. And we essentially will play back the log backwards to UNDO the latest action by the transaction, then the second, and so on, until the very start.</p> <ul> <li>We want to “play back” the log in <strong>reverse</strong> order, <strong>UNDOing</strong> updates.</li> </ul> <p><strong><em>So, where do we get the lastLSN of the transaction?</em></strong> We looked up in the <strong><em>transaction table</em></strong>.</p> <ul> <li>Get <code class="language-plaintext highlighter-rouge">lastLSN</code> of Xact from <strong>XT</strong>.</li> </ul> <p>We look it up to get what the latest update was. <strong><em>If it was a standard <code class="language-plaintext highlighter-rouge">update</code>, we UNDO it by taking the old data entry from the log record</em></strong>, and write it to memory. Flush to disk at some time.</p> <p>Once we’ve done that, we will follow our linked list backwards =&gt; looking at the <code class="language-plaintext highlighter-rouge">prevLSN</code> of the last log entry that we’ve UNDOne.</p> <ul> <li>Can follow chain of log records backward via the <code class="language-plaintext highlighter-rouge">prevLSN</code> field.</li> </ul> <p>Before we starting doing backwards traverse, we write an <code class="language-plaintext highlighter-rouge">Abort</code> log record. And this is important when we have a crash during this UNDO phase. Remeber that we wanted to abort this transaction.</p> <ul> <li>Before starting UNDO, write an <strong>Abort log record</strong>. <ul> <li>For recovering from crash during UNDO.</li> </ul> </li> </ul> <h3 id="abort-cont">Abort, cont.</h3> <p>First of all, we will be writing pages, and this is a running transaction. To perform UNDO, we must have a lock on data. But magically, we have the lock on the data because we are using S2PL. We only releasing a lock once the transaction commits. =&gt; It will not work if using C2PL as it releases locks gradually.</p> <ul> <li> <p>To perform UNDO, must have a lock on data!</p> <ul> <li>S2PL enforces this</li> </ul> </li> <li> <p>Before restoring old value of a page, write a CLR log record during the UNDO:</p> <ul> <li> <p>You continue logging while you UNDO!!</p> </li> <li> <p>CLR has on extra filed: <strong><code class="language-plaintext highlighter-rouge">undonextLSN</code></strong> =&gt; another sequential number</p> <ul> <li> <p>Points to the next LSN to undo (i.e., the <strong><code class="language-plaintext highlighter-rouge">prevLSN</code></strong> of the record we’re currently undoing).</p> </li> <li> <p>CLRs <strong><em>never</em></strong> Undone (but they might be Redone when repeating history: guarantees Atomicity!)</p> <p>They are never undone like. During Undo phase when we are performing UNDO records, we simply skip over them. But they might need to be redone when we redo these things again.</p> </li> </ul> </li> </ul> </li> <li> <p>At end of UNDO, write an <code class="language-plaintext highlighter-rouge">end</code> log record. =&gt; We reached the first action of the transaction and we will be using like a <code class="language-plaintext highlighter-rouge">NULL</code> pointer instead of the concrete pointer in the <code class="language-plaintext highlighter-rouge">prevLSN</code> for any first action performed by the transaction.</p> </li> </ul> <h3 id="example">Example</h3> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/od2vjF5.png" alt="image-20230106194011808" style="zoom:50%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <p>Solution: This is my RAM below to record what we have in the data structures as we go.</p> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/2rI6gKZ.png" alt="image-20230107004543282" style="zoom:50%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <h3 id="a-longer-example">A Longer Example</h3> <div align="center"> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <img src="https://i.imgur.com/S1ZctOH.jpeg" style="zoom:50%;" class="img-fluid rounded z-depth-1"> </div> </div> </div> <font color="red">**_`flushedLSN` has not effect on the tables._**</font> <h2 id="summary">Summary</h2> <p>Today is all about the normal execution of a transaction, including transaction commit, and transaction aborts. The next lecture, we are going to talk about <strong><em>Crash Recovery</em></strong>.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"LiuYing-1/liuying-1.github.io","data-repo-id":"R_kgDOJQ12MQ","data-category":"Announcements","data-category-id":"DIC_kwDOJQ12Mc4CVcDU","data-mapping":"pathname","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Y. Liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-JC70RZ57BT"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JC70RZ57BT");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>